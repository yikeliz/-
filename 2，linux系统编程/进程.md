# 进程

[TOC]



## 1，进程相关概念





### ps指令：

![image-20221021165802568](../图片/image-20221021165802568.png)

### 全部的线程：ps -aux 

这个太多了

### 得到含有名字的：ps -aux|grep 名字

![image-20221021165924869](../图片/image-20221021165924869.png)

### top指令：调用任务管理器

![image-20221021170026165](../图片/image-20221021170026165.png)

### pid:

getpid()得到自己的进程标识符

getppid()得到父进程的标识符

```c
#include <sys/types.h>
  2 #include <unistd.h>
  3 #include <stdio.h>
  4 int main()
  5 {
  6         pid_t pida = 0;
  7 
  8         pida = getpid();
  9 
 10         printf("pid = %d\n",pida);
 11 
 12         while(1);
 13 
 14         return 0;
 15 }
 16 
```

![image-20221021170823171](../图片/image-20221021170823171.png)

### C语言的代码程序内存地址分布：

代码段--数据段--bss段-堆和栈





## 2,创建进程函数fork的使用

### fork函数使用：创建一个进程

其实进程创建就是相当于把之前的代码拷贝一下，然后分开执行。

拷贝之前的linux和现在的不一样，之前是全部拷贝，现在的是进行写时拷贝，子进程需要修改某个变量的时候才进行拷贝，不需要修改就是共享变量。

返回值：

执行的循序是根据进程的调度。

#### 代码：

本代码是去了解进程的作用

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main()
{
	pid_t pida = 0;
	pid_t pidb = 0;

	pida = getpid();
	printf("before fork pid = %d\n",pida);

	pidb = fork();

	printf("after fork pid = %d\n",getpid());

	if(pidb > 0)
	{
		printf("father fork,%d\n",getpid());
	}
	else{

		printf("child fork,%d\n",getpid());
    }
	return 0;
}

```

#### 输出：

![image-20221023160242976](../图片/image-20221023160242976.png)





#### 代码

两个变量，不同进程的值是不一样的，这也解释了子进程进行了拷贝，然后修改。

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main()
{
	pid_t pida = 0;
	pid_t pidb = 0;
 	int data = 10;
	int *p = NULL;


	pida = getpid();
	printf("before fork pid = %d\n",pida);

	pidb = fork();

	if(pidb > 0)
	{
		printf("father fork,%d\n",getpid());
	}
	else{

		printf("child fork,%d\n",getpid());
		data += 10;
        }
	
 	p = &data;
	printf("data=%d,地址是%p这个\n",data,p);
	return 0;
}
```



#### 结果：

![image-20221023164307203](../图片/image-20221023164307203.png)



##### 问题是：

新的进程不是去拷贝data这个变量，然后进行修改，如果这样也的话，地址应该不一样吧，另外就是如果地址一样，那么相同地址的值不应该一样嘛，还是说这个要看进程。

##### 解决/答案：

根据答疑前辈的反馈，我进行了代码修改，直接取地址。

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main()
{
	pid_t pida = 0;
	pid_t pidb = 0;
 	int data = 10;


	pida = getpid();
	printf("before fork pid = %d\n",pida);

	pidb = fork();

	if(pidb > 0)
	{
		printf("father fork,%d\n",getpid());
	}
	else{
		printf("child fork,%d\n",getpid());
		data += 10;
        }
	
	printf("data=%d,地址是%p这个\n",data,&data);
	return 0;
}

```

##### 结果：

![image-20221024132204641](../图片/image-20221024132204641.png)



##### 验证：

然后我就加以验证，是不是说初始化的一样，未初始化的会不会地址不一样呢？

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main()
{
	pid_t pida = 0;
	pid_t pidb = 0;
 	int data;


	pida = getpid();
	printf("before fork pid = %d\n",pida);

	pidb = fork();

	if(pidb > 0)
	{
		printf("father fork,%d\n",getpid());
		data = 10;
	}
	else{

		printf("child fork,%d\n",getpid());
		data = 20;
        }
	
	printf("data=%d,地址是%p这个\n",data,&data);
	return 0;
}

```



##### 结果：

![image-20221024132330233](../图片/image-20221024132330233.png)



所以可得出其实新的进程是不是不会复制变量创建新的地址。最后的问题还是说，为啥地址一样，值还不一样？

##### 答案：

其实创建的地址都是虚拟地址，那么虚拟地址的地址一样也很正常，保证所有的东西和之前一样。

![image-20221024232421215](../图片/image-20221024232421215.png)

![image-20221024232345826](../图片/image-20221024232345826.png)





## 3，进程创建的目的和实际场景

### 1，socket服务器，在收到服务请求，创建子进程对接

#### 简单的代码：

就是两个while循环，检测输入的数据和预设的数据是否相同，如果相同，那么创建线程，如果不同，什么事情都不做

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main()
{
	pid_t pida = 0;
	int data = 0;

	while(1){		
		printf("please input your data\n");
		scanf("%d",&data);
		if(data == 1)
		{
			pida = fork();
			if(pida >0 )
			{
			}
			else if(pida == 0){
				while(1)
				{
					printf("witing child data,pid is %d\n",getpid());
					sleep(3);
				}
			}
		}
		else{
			printf("witing father data\n");
        	}

	}
	return 0;
}

```

#### 输出：

![image-20221024170836236](../图片/image-20221024170836236.png)



### 2，一个进程要执行一个不同的程序（exec）

子进程从fork返回后立即调用exec(之后说明)





## 4,vfork创建线程

### 1，与fork区别

1）直接利用父进程存储空间，不拷贝

2）保证子进程先运行，当子进程调用exit()退出之后父进程在执行



这个代码明天补上



### 2，进程退出

#### 正常退出

1）main函数调用return

2 ）进程调用exit(),标准c库

3）进程调用_exit()或者__Exit(),属于系统调用

最后一个线程返回

最后一个进程掉头pthread_exit



#### 异常退出

1）调用abort

2）当进程接收到某些信号，如ctrl+c

3）最后一个线程对取消，请求做出响应

